# Мои мысли по поводу задачи
## Предметная область и валидация  
Изначально номер рейса был заложен как целое число без знака, но, поискав информацию, обнаружил, что вообще его формат 2 цифры или латинских буквы, затем от одной до 3х цифр. Или, переводя в язык регулярок что-то вроде ^[0-9A-Za-z]{2}\d{1,3}$. Подзадача показалась мне интересной, тем более, что хорошо прогоняется юнит-тестами, и я за неё плотно сел. Проблем с валидацией на стороне кода не было, были написаны несколько разных вариантов (все с регуляркой; ValidationRule и реализация INotifyDataErrorInfo), и строку в таблице они успешно инвалидировали. Но вот всплывающее окно, вызываемое через привязку стиля при ошибках валидации вылезать и выдавать сообщение не хотело. Таким образом в итоге я отказался пока что от валидации поля и оставил это на совести пользователя. Буду разбираться в ближайшее свободное время, как же всё-таки сделать желаемую выдачу корректно в рамках WPF.

## Объектная составляющая решения  
Т.к. у нас стоит одна конкретная задача с одним и тем же видом выборки одних и тех же данных, нам достаточно одной модели и вьюшки к ней. По-хорошему, в реальном проекте, где объект "Пассажир" и объект "Рейс" являются независимыми сущностями со связью многие-ко-многим, для каждого из них нужны свои модели (и, скорее всего, уникальные ключи в виде Guid-а в свойстве для реализации этой связи). В случае же текущей задачи, где нам нужна лишь сводная таблица, это оверинжиниринг.  
Из типичных для ООП конструкций получилось выделить, пожалуй, логику кнопок и автозаполнения свойств FileDialog при их вызовах.

## Юнит-тесты  
Если бы получилось сделать корректную валидацию на стороне UI, то со стороны бэка она отлично оттестировалась бы, выделенная в отдельный интерфейс с методами. Без неё же большая часть работы приложения либо использует функции стандартных библиотек, либо требует взаимодействия с пользователем через UI и, следовательно, интеграционных тестов. Можно было бы кинуть юнит-тест на работоспособность ApplySettingsToFileDialog метода, или на GetDeserializedContentFromFileStreamAsync из AddFromButtonLogic, но не стал уже этого делать из-за итак подорванных сроков.

## Формат хранения данных  
Выбран Json, как формат, имеющий отличные методы конвертации в него и обратно в стандартной поставке платформы, (либо можно использовать Newtonsoft для легаси), при легковесный и универсальный, читается любым вендором на любом языке и платформе. К сожалению, как и XML, и другие универсальные форматы, не являющиеся БД, не предназначен для замены какого-то конкретного объекта или свойства конкретного объекта без перезаписывания остальной части файла. Из этого вытекают потенциальные проблемы производительности, для таких задач я бы использовал СУБД.

## Остальные мысли о потенциальной оптимизации решения  
Помимо валидации есть ещё вопросы с быстродействием работы обрабатывающих файлы функций на больших объемах данных (как сказано выше, текущее решение пишет и читает файл с начала и до конца, чтобы корректно его распарсить), а также с логированием. Сейчас логирования в проекте нет, исключения летят пользователю в виде сообщений, было бы время - реализовал бы, при этом, скорее всего, использовал бы какой-нибудь NLog.